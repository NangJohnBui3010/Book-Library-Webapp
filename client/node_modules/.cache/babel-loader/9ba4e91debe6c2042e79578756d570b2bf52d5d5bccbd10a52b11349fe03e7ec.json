{"ast":null,"code":"import { focusOn } from './commands';\nimport { getTabbableNodes, contains, getFocusableNodes } from './utils/DOMutils';\nimport { asArray } from './utils/array';\n/**\n * for a given `element` in a given `scope` returns focusable siblings\n * @param element - base element\n * @param scope - common parent. Can be document, but better to narrow it down for performance reasons\n * @returns {prev,next} - references to a focusable element before and after\n * @returns undefined - if operation is not applicable\n */\nexport var getRelativeFocusable = function (element, scope, useTabbables) {\n  if (!element || !scope) {\n    console.error('no element or scope given');\n    return {};\n  }\n  var shards = asArray(scope);\n  if (shards.every(function (shard) {\n    return !contains(shard, element);\n  })) {\n    console.error('Active element is not contained in the scope');\n    return {};\n  }\n  var focusables = useTabbables ? getTabbableNodes(shards, new Map()) : getFocusableNodes(shards, new Map());\n  var current = focusables.findIndex(function (_a) {\n    var node = _a.node;\n    return node === element;\n  });\n  if (current === -1) {\n    // an edge case, when anchor element is not found\n    return undefined;\n  }\n  return {\n    prev: focusables[current - 1],\n    next: focusables[current + 1],\n    first: focusables[0],\n    last: focusables[focusables.length - 1]\n  };\n};\nvar getBoundary = function (shards, useTabbables) {\n  var set = useTabbables ? getTabbableNodes(asArray(shards), new Map()) : getFocusableNodes(asArray(shards), new Map());\n  return {\n    first: set[0],\n    last: set[set.length - 1]\n  };\n};\nvar defaultOptions = function (options) {\n  return Object.assign({\n    scope: document.body,\n    cycle: true,\n    onlyTabbable: true\n  }, options);\n};\nvar moveFocus = function (fromElement, options, cb) {\n  if (options === void 0) {\n    options = {};\n  }\n  var newOptions = defaultOptions(options);\n  var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);\n  if (!solution) {\n    return;\n  }\n  var target = cb(solution, newOptions.cycle);\n  if (target) {\n    focusOn(target.node, newOptions.focusOptions);\n  }\n};\n/**\n * focuses next element in the tab-order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusNextElement = function (fromElement, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  moveFocus(fromElement, options, function (_a, cycle) {\n    var next = _a.next,\n      first = _a.first;\n    return next || cycle && first;\n  });\n};\n/**\n * focuses prev element in the tab order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusPrevElement = function (fromElement, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  moveFocus(fromElement, options, function (_a, cycle) {\n    var prev = _a.prev,\n      last = _a.last;\n    return prev || cycle && last;\n  });\n};\nvar pickBoundary = function (scope, options, what) {\n  var _a;\n  var boundary = getBoundary(scope, (_a = options.onlyTabbable) !== null && _a !== void 0 ? _a : true);\n  var node = boundary[what];\n  if (node) {\n    focusOn(node.node, options.focusOptions);\n  }\n};\n/**\n * focuses first element in the tab-order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusFirstElement = function (scope, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  pickBoundary(scope, options, 'first');\n};\n/**\n * focuses last element in the tab order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusLastElement = function (scope, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  pickBoundary(scope, options, 'last');\n};","map":{"version":3,"names":["focusOn","getTabbableNodes","contains","getFocusableNodes","asArray","getRelativeFocusable","element","scope","useTabbables","console","error","shards","every","shard","focusables","Map","current","findIndex","_a","node","undefined","prev","next","first","last","length","getBoundary","set","defaultOptions","options","Object","assign","document","body","cycle","onlyTabbable","moveFocus","fromElement","cb","newOptions","solution","target","focusOptions","focusNextElement","focusPrevElement","pickBoundary","what","boundary","focusFirstElement","focusLastElement"],"sources":["D:/IT/learn_node/books/client/node_modules/focus-lock/dist/es2015/sibling.js"],"sourcesContent":["import { focusOn } from './commands';\nimport { getTabbableNodes, contains, getFocusableNodes } from './utils/DOMutils';\nimport { asArray } from './utils/array';\n/**\n * for a given `element` in a given `scope` returns focusable siblings\n * @param element - base element\n * @param scope - common parent. Can be document, but better to narrow it down for performance reasons\n * @returns {prev,next} - references to a focusable element before and after\n * @returns undefined - if operation is not applicable\n */\nexport var getRelativeFocusable = function (element, scope, useTabbables) {\n    if (!element || !scope) {\n        console.error('no element or scope given');\n        return {};\n    }\n    var shards = asArray(scope);\n    if (shards.every(function (shard) { return !contains(shard, element); })) {\n        console.error('Active element is not contained in the scope');\n        return {};\n    }\n    var focusables = useTabbables\n        ? getTabbableNodes(shards, new Map())\n        : getFocusableNodes(shards, new Map());\n    var current = focusables.findIndex(function (_a) {\n        var node = _a.node;\n        return node === element;\n    });\n    if (current === -1) {\n        // an edge case, when anchor element is not found\n        return undefined;\n    }\n    return {\n        prev: focusables[current - 1],\n        next: focusables[current + 1],\n        first: focusables[0],\n        last: focusables[focusables.length - 1],\n    };\n};\nvar getBoundary = function (shards, useTabbables) {\n    var set = useTabbables\n        ? getTabbableNodes(asArray(shards), new Map())\n        : getFocusableNodes(asArray(shards), new Map());\n    return {\n        first: set[0],\n        last: set[set.length - 1],\n    };\n};\nvar defaultOptions = function (options) {\n    return Object.assign({\n        scope: document.body,\n        cycle: true,\n        onlyTabbable: true,\n    }, options);\n};\nvar moveFocus = function (fromElement, options, cb) {\n    if (options === void 0) { options = {}; }\n    var newOptions = defaultOptions(options);\n    var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);\n    if (!solution) {\n        return;\n    }\n    var target = cb(solution, newOptions.cycle);\n    if (target) {\n        focusOn(target.node, newOptions.focusOptions);\n    }\n};\n/**\n * focuses next element in the tab-order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusNextElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    moveFocus(fromElement, options, function (_a, cycle) {\n        var next = _a.next, first = _a.first;\n        return next || (cycle && first);\n    });\n};\n/**\n * focuses prev element in the tab order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusPrevElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    moveFocus(fromElement, options, function (_a, cycle) {\n        var prev = _a.prev, last = _a.last;\n        return prev || (cycle && last);\n    });\n};\nvar pickBoundary = function (scope, options, what) {\n    var _a;\n    var boundary = getBoundary(scope, (_a = options.onlyTabbable) !== null && _a !== void 0 ? _a : true);\n    var node = boundary[what];\n    if (node) {\n        focusOn(node.node, options.focusOptions);\n    }\n};\n/**\n * focuses first element in the tab-order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusFirstElement = function (scope, options) {\n    if (options === void 0) { options = {}; }\n    pickBoundary(scope, options, 'first');\n};\n/**\n * focuses last element in the tab order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusLastElement = function (scope, options) {\n    if (options === void 0) { options = {}; }\n    pickBoundary(scope, options, 'last');\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}